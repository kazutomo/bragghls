#map = affine_map<(d0, d1) -> (d0 + d1)>
module attributes {torch.debug_module_name = "DoubleCNN"} {
  memref.global "private" constant @__constant_16x1x3x3xf32 : memref<16x1x3x3xf32> = dense<"0xE0383DBE8CDBA8BE400BB53C446D87BE101858BE2BA304BE5C92CC3DFC3BC03D065E5D3E0BEA7FBE2CBC94BDB81878BD3BAA7EBED0DBDB3D3AD5593E7A07373E60119ABE7E4B703ECEA52A3EE84E9EBEF233413E565B563E444998BEEECF4EBEE80A053D621F593E406641BDE030E5BDD7EF963E06B855BEE400A7BD80E34EBEF80C17BE1DF98F3E88171CBE83829FBEA8B609BD684E4C3D0024B4B9CCF2D23DD3D7A73E1492FB3D8130933E184F70BE75129C3E0030FC39188111BDB0D484BE009E3ABBFC3BE7BDDC999C3DEE2B3ABEEAAE7D3E98D8033EB768A43ED8DB7CBE40AC3EBEC49C86BE06C3183E7CCFD63DB6467FBE88AA1ABD0444803D007158BC7DE7823E269728BE902C0C3E40EE043D40F097BD385169BD1F789FBE1D869B3E7A42213E1F5C8F3E1092D4BCA9B1953E681E11BD60BC523C306CD3BDB295793E99EB953E6C59D73D70D7E0BD209162BE80B31CBE1C6695BEB186A13E9BBA28BE9C7CA9BD68C80A3E3B5CA93EFAC17E3EDE00303E541992BD70D69D3CE00998BD605E233E6096033CFE2F83BE68DB263E44DEA9BD6B2760BED626DBBDF89150BD60963A3CF5D48F3E4C6591BD66F25D3EEED3773ECFF5A33E7A5E3C3EC1F7953ED0C45DBE8073303C508D76BE165F52BEA612453E60171C3EC008C83DC7B591BE4063A83C051C883E6E72163E26F00EBEE39461BE4CE9F73D6BDD863E8057373DEE893C3EDC5B88BECD528C3E8B71A3BEA3D12ABE5EFD4DBEA0E6693D6DC5A63E76CFAFBD13C652BE4C6D94BDC056E73CA6E049BEF082C13D001239BBA4D58A3D">
  memref.global "private" constant @__constant_16xf32_0 : memref<16xf32> = dense<[-0.129560158, 0.254562467, -0.0320248604, -0.305575252, 0.289485067, 0.182605058, 0.266014606, 0.121456742, -0.259806335, 0.332867175, 0.244990855, -0.233904809, -0.140601799, 0.229883164, -0.119784445, 0.109039515]>
  memref.global "private" constant @__constant_8x16x1x1xf32_1 : memref<8x16x1x1xf32> = dense<"0x00CA2D3DCC30A93D2EA473BE7C8ED03D00D17D3BB6A6463EE0DCEE3D668B4CBE9EFE6EBE0AA45C3E48FCA33D18EA533EB038B03C903F6F3E20DCF73D9408163EB044DEBC24D0133E301E25BE26A8253EFA613CBE1E072CBE54E7A1BDD0B9F03D226714BE105557BE00C6483A5EAB58BE003CB63B80F4EE3B66D07B3E440B7EBE7C0DC23D08E9553D2081D0BDDC2AB93D94808CBDB8C05ABDC807E2BD782E543E4CA5843DBC4F82BDB035DD3D58DB0D3D128E41BE5C4D233E9CD1E93D50A3D13C6C9559BE0CB1F1BD62995F3E78A6C13DEEAB37BE8E3213BED01156BE7CCEAA3D68722F3EC85D20BD181A2A3DC8B951BEA83F3EBD586960BEAC3A203EDA982D3E20A24B3EA481BEBD3CDF2F3E0C8844BE1CD38D3D50BCCABDAE95223EA467C4BD68B77EBEE03F0F3E5ADC2A3E4ED9203E0086D73BD0D14E3EDEF96D3E34283CBEC8442D3D0CFE873D68E62ABEB08CFFBC3039CF3D126370BE4C097A3E4E3E14BEB893153DE095AABCC84DF33DBEC12ABEE0559EBC604467BD1457A03D7258633EB2FF07BECE95433E00F14FBC62953A3E10EF74BED030DABC90D83CBE549F46BE9C92BF3DD02412BD3049303E8C5E32BEFA5253BE80AD40BBA2D20E3E8E437A3EBE215C3E9CB8C63D5082A4BC208F513D24D1983DC4C96B3E8400FA3DE0F27ABCAA281F3ED425EB3DE02566BCE0ADC5BD1C5E45BE5CDE973DB68134BE182F26BE">
  memref.global "private" constant @__constant_8xf32_1 : memref<8xf32> = dense<[0.0611416101, 0.228176326, -0.00933715701, 0.165543854, 0.175165057, 0.188539684, 0.0448108315, -0.0385988951]>
  memref.global "private" constant @__constant_8x16x1x1xf32_0 : memref<8x16x1x1xf32> = dense<"0x9469663E524D3CBE40B3D73C50A50D3EF45BFEBD9C89CD3D90D7BB3C34E7033EC0B2FF3D5C436D3E94348D3D12DE3C3EC853883DF4FB97BD7AD4423E4CF4C6BDE04E73BECCCF12BEF498083E189172BEA0EC483D782F68BEC0C7CF3B04B5DD3D62DF32BE76816E3E20B0203E9E056A3E00BE593C8036CB3CB888093E2EC70C3EC01C233C502A793E74FB293ECECE26BE0C59713E784EF7BD4ABA303E20FD57BD623E773E0EB70B3E6A773BBE903D64BDF6626E3EA0C65E3C80950A3E8059773E00B88EBDA0D1093ED02AC93D00BB57BB525749BE8C57E33DB4F0F23DBCD2E6BD0086F9BDD2C0783E308835BE1039833DDA4D7FBE020C63BE3270683EF8ED753D3E7B5EBE50D7D0BDE61938BE1C0B7FBE78E081BD78D4773E883900BEF63371BE9A8E273EDC96F93D14441E3E84545CBE44193A3EAA0B40BEE450D43D005FB0BC7851F8BD42FC703E709E353EF0C56EBD586B483D147ABD3D922553BE20635BBC005422BA281701BE1C2FC13DDC2BB93DA03482BD701BF73CF8B571BE8A71443E80385EBC8230553EA4AA6DBEEEF05FBEFC75A03D5EBA673E403A763CCE806FBEC0631BBCE4931B3E2AD85FBEAC247FBE505D603E44BB463E5E940EBE2C9B40BEC0D9E3BCBA4D643E446354BEBEF9043EC08AB8BBD677593EC4B4C7BD1445ADBD36D4523E70285B3DB0324C3E2094CEBD92B4713E0254393E580FCB3DE660293E">
  memref.global "private" constant @__constant_8xf32_0 : memref<8xf32> = dense<[0.0849818885, -0.184861422, -0.0475964546, 0.13199231, -0.0422819853, -0.232527137, -0.0634448528, -0.130168229]>
  memref.global "private" constant @__constant_8x16x1x1xf32 : memref<8x16x1x1xf32> = dense<"0x1C8C9A3D080DE13D0AAF223E5E731B3EA2E5153EF04E73BEE6624D3E5876093DC872E03D1CF0EB3D6A9838BE40CB79BE52330CBE5639743E7AB8693E60AA57BCD8404BBD4C136CBE00D078BC1A615CBEB0647BBDB01463BEECE96ABED48FE5BD160A013EA0AED2BC2C321F3E90FE9CBD2846233D4084993CE86328BE20A6973CACB62EBE189556BE0C216F3EB8EB4EBE1C59F7BDD619583E9822113EF47136BE8814873D84CAD63DB844573D9014EBBCB892333E20AFB7BD90B654BD405009BEF41205BE244826BEEEAA57BE5A5271BEAE6314BE80F26A3C48C577BE6C91ABBD32E7643E0C9B4C3E207234BD4086653CFEE61FBE84DE133E6018BFBD10229DBD9421C0BD58301BBE783497BDC09E6D3DF0F7613D7CA165BE5ACA0ABE3A0B0DBEEC5A493E0CCF81BD9047D43D40AFD5BD202535BEF6D30F3E1C5E02BE408936BD50A762BD60462A3E10C71DBD2E8C5D3E00B14ABB8012DA3C72FD6C3E70987B3E5CFD9EBDC2CC543EA0B0A03CF0CE1C3EA0C2DDBD66026CBE5481223E1AC04C3EF88CF03D9CE1F93DE05435BD58583E3DAE4B3FBEA44452BE2431BCBD8EE337BE04FE5A3E00580D3E9E3F383E30FB1A3EF2EB5A3E16C94C3EB2E419BE1810033EEA85133ED6AB683E1089DEBC98B327BD3E280DBEAC6F533E940C8E3D6432D83D0A1326BE183147BD624452BE004088BDA0860EBD1CC5FF3D621721BEFCAA60BE">
  memref.global "private" constant @__constant_8xf32 : memref<8xf32> = dense<[-0.0841903984, 0.111509383, 1.986570e-01, -0.232849449, 0.0660006404, -0.224090964, -0.199056953, 0.19479087]>
  memref.global "private" constant @__constant_16x8x1x1xf32 : memref<16x8x1x1xf32> = dense<"0x938FAF3E00464F3A52FF273E1229463E589F113ECF6D8D3EA7EF20BEE80A5B3D5C9409BEF90327BE082E9E3DC1F2823E103B5BBD4AFE793E61F4ADBEA0EC35BD961E383E4544853EA6CCDABDE6843B3ECEFB66BE54C3AA3D4FD1923E489921BEAAEF013E4215073EF376AD3E7861033ED46DCC3D9DCC38BED7D0B4BECCD7C2BD1DAA943E8A36293EDD6F933EA887F03D5A82023EADCEAEBE87B28BBE2A3D2E3E001ED5BA3483AD3D7FE1ACBEDCF1C33DF4DEDCBDBEBE2B3E98EB48BDC5DA44BE827841BE688A5E3D84078EBD539885BE9B728F3EA44FA83DE80E773DB130893E2820213D4D9DA23EC0E2E7BBF740AA3E8258333E0238533E229780BE0A7B2CBE369D403E19838FBE273989BE50CCDA3CE0445DBECBB726BEBE2776BECEE78EBE9280243E9C2AAABD16187E3EAC6AF13D989D5DBDCCE6913D5E1AA6BEC858303D7C74A6BE201BB23C2E548DBE82595D3EF4C1C93D92D2F3BD805EBEBB00AFA6BE0F2098BE70B6BEBCA88A95BE28F01B3D103FA0BEA21F243E44FDE6BDD744A7BE40AE043C8C2708BE3A477C3E95638A3E831A893E7170973E78CEE8BD305B303D3C11DFBDF128923EA109A73E9FAA07BE433D14BEC01D6BBCC42A09BE22941E3EAD67A73E8D8CA53EA6DD193ED03D75BDC897143DBB00B43EA285753E741AD93DC1FF893EDCD88FBE3D369E3EC280073E14AE87BE5DB681BEB8AD13BD3DC75DBE">
  memref.global "private" constant @__constant_16xf32 : memref<16xf32> = dense<[0.1125063, 0.0725470185, -0.208454818, 0.195086867, 0.0828484892, 0.0358458161, -0.228733853, 0.323264033, -0.0515337884, 0.145014703, -0.00474780798, 0.0437609851, 0.0401950777, 0.00359800458, 0.286392599, 0.297756463]>
  func.func @forward(%arg0: memref<1x1x5x5xf32>) -> memref<f32> {
    %c16 = arith.constant 16 : index
    %c1 = arith.constant 1 : index
    %c3 = arith.constant 3 : index
    %c0 = arith.constant 0 : index
    %c8 = arith.constant 8 : index
    %cst = arith.constant 0.000000e+00 : f32
    %0 = memref.get_global @__constant_16xf32 : memref<16xf32>
    %1 = memref.get_global @__constant_16x8x1x1xf32 : memref<16x8x1x1xf32>
    %2 = memref.get_global @__constant_8xf32 : memref<8xf32>
    %3 = memref.get_global @__constant_8x16x1x1xf32 : memref<8x16x1x1xf32>
    %4 = memref.get_global @__constant_8xf32_0 : memref<8xf32>
    %5 = memref.get_global @__constant_8x16x1x1xf32_0 : memref<8x16x1x1xf32>
    %6 = memref.get_global @__constant_8xf32_1 : memref<8xf32>
    %7 = memref.get_global @__constant_8x16x1x1xf32_1 : memref<8x16x1x1xf32>
    %8 = memref.get_global @__constant_16xf32_0 : memref<16xf32>
    %9 = memref.get_global @__constant_16x1x3x3xf32 : memref<16x1x3x3xf32>
    %10 = memref.alloca() : memref<1x16x3x3xf32>
    scf.parallel (%arg1, %arg2, %arg3, %arg4) = (%c0, %c0, %c0, %c0) to (%c1, %c16, %c3, %c3) step (%c1, %c1, %c1, %c1) {
      %24 = memref.load %8[%arg2] : memref<16xf32>
      memref.store %24, %10[%arg1, %arg2, %arg3, %arg4] : memref<1x16x3x3xf32>
      scf.yield
    }
    %11 = memref.alloca() : memref<1x16x3x3xf32>
    memref.copy %10, %11 : memref<1x16x3x3xf32> to memref<1x16x3x3xf32>
    scf.parallel (%arg1, %arg2, %arg3, %arg4) = (%c0, %c0, %c0, %c0) to (%c1, %c16, %c3, %c3) step (%c1, %c1, %c1, %c1) {
      scf.for %arg5 = %c0 to %c1 step %c1 {
        scf.for %arg6 = %c0 to %c3 step %c1 {
          scf.for %arg7 = %c0 to %c3 step %c1 {
            %24 = affine.apply #map(%arg3, %arg6)
            %25 = affine.apply #map(%arg4, %arg7)
            %26 = memref.load %arg0[%arg1, %arg5, %24, %25] : memref<1x1x5x5xf32>
            %27 = memref.load %9[%arg2, %arg5, %arg6, %arg7] : memref<16x1x3x3xf32>
            %28 = memref.load %11[%arg1, %arg2, %arg3, %arg4] : memref<1x16x3x3xf32>
            %29 = arith.mulf %26, %27 : f32
            %30 = arith.addf %28, %29 : f32
            memref.store %30, %11[%arg1, %arg2, %arg3, %arg4] : memref<1x16x3x3xf32>
          }
        }
      }
      scf.yield
    }
    %12 = memref.alloca() : memref<1x8x3x3xf32>
    scf.parallel (%arg1, %arg2, %arg3, %arg4) = (%c0, %c0, %c0, %c0) to (%c1, %c8, %c3, %c3) step (%c1, %c1, %c1, %c1) {
      %24 = memref.load %6[%arg2] : memref<8xf32>
      memref.store %24, %12[%arg1, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
      scf.yield
    }
    %13 = memref.alloca() : memref<1x8x3x3xf32>
    memref.copy %12, %13 : memref<1x8x3x3xf32> to memref<1x8x3x3xf32>
    scf.parallel (%arg1, %arg2, %arg3, %arg4) = (%c0, %c0, %c0, %c0) to (%c1, %c8, %c3, %c3) step (%c1, %c1, %c1, %c1) {
      scf.for %arg5 = %c0 to %c16 step %c1 {
        scf.for %arg6 = %c0 to %c1 step %c1 {
          scf.for %arg7 = %c0 to %c1 step %c1 {
            %24 = affine.apply #map(%arg3, %arg6)
            %25 = affine.apply #map(%arg4, %arg7)
            %26 = memref.load %11[%arg1, %arg5, %24, %25] : memref<1x16x3x3xf32>
            %27 = memref.load %7[%arg2, %arg5, %arg6, %arg7] : memref<8x16x1x1xf32>
            %28 = memref.load %13[%arg1, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
            %29 = arith.mulf %26, %27 : f32
            %30 = arith.addf %28, %29 : f32
            memref.store %30, %13[%arg1, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
          }
        }
      }
      scf.yield
    }
    %14 = memref.alloca() : memref<1x8x3x3xf32>
    scf.parallel (%arg1, %arg2, %arg3, %arg4) = (%c0, %c0, %c0, %c0) to (%c1, %c8, %c3, %c3) step (%c1, %c1, %c1, %c1) {
      %24 = memref.load %4[%arg2] : memref<8xf32>
      memref.store %24, %14[%arg1, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
      scf.yield
    }
    %15 = memref.alloca() : memref<1x8x3x3xf32>
    memref.copy %14, %15 : memref<1x8x3x3xf32> to memref<1x8x3x3xf32>
    scf.parallel (%arg1, %arg2, %arg3, %arg4) = (%c0, %c0, %c0, %c0) to (%c1, %c8, %c3, %c3) step (%c1, %c1, %c1, %c1) {
      scf.for %arg5 = %c0 to %c16 step %c1 {
        scf.for %arg6 = %c0 to %c1 step %c1 {
          scf.for %arg7 = %c0 to %c1 step %c1 {
            %24 = affine.apply #map(%arg3, %arg6)
            %25 = affine.apply #map(%arg4, %arg7)
            %26 = memref.load %11[%arg1, %arg5, %24, %25] : memref<1x16x3x3xf32>
            %27 = memref.load %5[%arg2, %arg5, %arg6, %arg7] : memref<8x16x1x1xf32>
            %28 = memref.load %15[%arg1, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
            %29 = arith.mulf %26, %27 : f32
            %30 = arith.addf %28, %29 : f32
            memref.store %30, %15[%arg1, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
          }
        }
      }
      scf.yield
    }
    %16 = memref.alloca() : memref<1x8x3x3xf32>
    scf.parallel (%arg1, %arg2, %arg3, %arg4) = (%c0, %c0, %c0, %c0) to (%c1, %c8, %c3, %c3) step (%c1, %c1, %c1, %c1) {
      %24 = memref.load %2[%arg2] : memref<8xf32>
      memref.store %24, %16[%arg1, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
      scf.yield
    }
    %17 = memref.alloca() : memref<1x8x3x3xf32>
    memref.copy %16, %17 : memref<1x8x3x3xf32> to memref<1x8x3x3xf32>
    scf.parallel (%arg1, %arg2, %arg3, %arg4) = (%c0, %c0, %c0, %c0) to (%c1, %c8, %c3, %c3) step (%c1, %c1, %c1, %c1) {
      scf.for %arg5 = %c0 to %c16 step %c1 {
        scf.for %arg6 = %c0 to %c1 step %c1 {
          scf.for %arg7 = %c0 to %c1 step %c1 {
            %24 = affine.apply #map(%arg3, %arg6)
            %25 = affine.apply #map(%arg4, %arg7)
            %26 = memref.load %11[%arg1, %arg5, %24, %25] : memref<1x16x3x3xf32>
            %27 = memref.load %3[%arg2, %arg5, %arg6, %arg7] : memref<8x16x1x1xf32>
            %28 = memref.load %17[%arg1, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
            %29 = arith.mulf %26, %27 : f32
            %30 = arith.addf %28, %29 : f32
            memref.store %30, %17[%arg1, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
          }
        }
      }
      scf.yield
    }
    %18 = memref.alloca() : memref<1x8x3x3xf32>
    scf.parallel (%arg1, %arg2, %arg3, %arg4) = (%c0, %c0, %c0, %c0) to (%c1, %c8, %c3, %c3) step (%c1, %c1, %c1, %c1) {
      %24 = memref.load %13[%c0, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
      %25 = memref.load %15[%c0, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
      %26 = arith.addf %24, %25 : f32
      memref.store %26, %18[%arg1, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
      scf.yield
    }
    %19 = memref.alloca() : memref<1x8x3x3xf32>
    scf.parallel (%arg1, %arg2, %arg3, %arg4) = (%c0, %c0, %c0, %c0) to (%c1, %c8, %c3, %c3) step (%c1, %c1, %c1, %c1) {
      %24 = memref.load %18[%c0, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
      %25 = memref.load %17[%c0, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
      %26 = arith.addf %24, %25 : f32
      memref.store %26, %19[%arg1, %arg2, %arg3, %arg4] : memref<1x8x3x3xf32>
      scf.yield
    }
    %20 = memref.alloca() : memref<1x16x3x3xf32>
    scf.parallel (%arg1, %arg2, %arg3, %arg4) = (%c0, %c0, %c0, %c0) to (%c1, %c16, %c3, %c3) step (%c1, %c1, %c1, %c1) {
      %24 = memref.load %0[%arg2] : memref<16xf32>
      memref.store %24, %20[%arg1, %arg2, %arg3, %arg4] : memref<1x16x3x3xf32>
      scf.yield
    }
    %21 = memref.alloca() : memref<1x16x3x3xf32>
    memref.copy %20, %21 : memref<1x16x3x3xf32> to memref<1x16x3x3xf32>
    scf.parallel (%arg1, %arg2, %arg3, %arg4) = (%c0, %c0, %c0, %c0) to (%c1, %c16, %c3, %c3) step (%c1, %c1, %c1, %c1) {
      scf.for %arg5 = %c0 to %c8 step %c1 {
        scf.for %arg6 = %c0 to %c1 step %c1 {
          scf.for %arg7 = %c0 to %c1 step %c1 {
            %24 = affine.apply #map(%arg3, %arg6)
            %25 = affine.apply #map(%arg4, %arg7)
            %26 = memref.load %19[%arg1, %arg5, %24, %25] : memref<1x8x3x3xf32>
            %27 = memref.load %1[%arg2, %arg5, %arg6, %arg7] : memref<16x8x1x1xf32>
            %28 = memref.load %21[%arg1, %arg2, %arg3, %arg4] : memref<1x16x3x3xf32>
            %29 = arith.mulf %26, %27 : f32
            %30 = arith.addf %28, %29 : f32
            memref.store %30, %21[%arg1, %arg2, %arg3, %arg4] : memref<1x16x3x3xf32>
          }
        }
      }
      scf.yield
    }
    %22 = memref.alloca() : memref<f32>
    memref.store %cst, %22[] : memref<f32>
    %23 = memref.alloc() {alignment = 128 : i64} : memref<f32>
    memref.copy %22, %23 : memref<f32> to memref<f32>
    scf.for %arg1 = %c0 to %c1 step %c1 {
      scf.for %arg2 = %c0 to %c16 step %c1 {
        scf.for %arg3 = %c0 to %c3 step %c1 {
          scf.for %arg4 = %c0 to %c3 step %c1 {
            %24 = memref.load %21[%arg1, %arg2, %arg3, %arg4] : memref<1x16x3x3xf32>
            %25 = memref.load %23[] : memref<f32>
            %26 = arith.addf %24, %25 : f32
            memref.store %26, %23[] : memref<f32>
          }
        }
      }
    }
    return %23 : memref<f32>
  }
}
